# CI/CD

CI/CD является одной из DevOps-практик, поскольку направлена на борьбу с противоречиями между разработчиками, которые хотят часто вносить изменения, и эксплуатацией, требующей стабильности.

CI/CD - набор практик и принципов который заключается в обеспечении непрерывной интеграции и непрерывной поставке. Позволяет разрабочикам сразу получать фит бек. Позволяет разработчикам сосредоточиться на разработке кода и др.

Цель CI/CD - - ускорение разработки програмного кода. CI/CD обеспечивает более частое развертывание кода.

## CI

CI(Continuous Integration) -  набор практик для разработки ПО с небольшими изменениями и частыми коммитами.

Цели CI:
1. Автоматизированая сборка
2. Автоматизированная упаковка
3. Автоматическое тестирование (в случае провала автоматический откат)
3. 1. Проверка кода на синтаксис.

## CD

CD(Continuous Delivery) - Автоматическая отправка обьектов в среду

CD(Continuous Deployment) - Автоматическая отправка обьектов и развертывание их в приложении

Цели CD:

1. Получение кода из системы контроля версий и выполнение сборки.
2. Развертывание компонентов(обьектов) приложения
3. Логирование и отправка оповещений о состоянии поставки.

?требуется дополнить?

# Infrastructure as code (IaC)

IaC — это подход для управления и описания инфраструктуры через конфигурационные файлы, а не через ручное редактирование конфигураций на серверах.

IaC - позволяет автоматически разворачивать, обновлять инфраструктуру через конфирурационные файлы специальных тулов специальные тулы (Terraform, Ansible)

## IaC better when script?

Например terraform при повторном запуске обновляет инфраструктуру, которая уже запущена и приводит ее к состоянию конфигурационном файле(в том случае если инфраструктура создавалась с terraform, рабочет с помощью .tfstate file). Обычные команды или скрипты на выход дадут ошибку, т.к инфраструктура уже существует.



# Terrafom 

`terraform init` - пройдется по всем  .tf файлам и скачивает необходимые плагины для работы. Например плагин для Azure или AWS

`terraform plan` - показывает что будет делать(добавлять и тд) после apply

`terraform apply` - выполняет дейстия, которые указаны в .tf файлах. Создает `.tfstate` файл с помощью него проверяет состояние, параметры инфраструктуры. Если При повторном запуске apply будет просто обновлять инфраструктуру к состоянию, которое указано в .tf файлах. Если удалить .tfstate файл, и запустить apply, то создаст инфраструктура заново.

`tfsate` лучше хранить удалено для доступа к нему других разработчиков, например в удаленном репозитории.


# Declarative/Scripted Pipeline syntax

__Declarative Pipeline__

В декларативном синтаксисе объявляются вложенные конструкции - получается матрёшка. На верхнем уровне - пайплайн (Pipeline), который состоит из этапов (Stages) . Этапы состоят из  шагов (Steps), шагами могут быть как отдельные операторы, вызовы функций, так и скрипты (Script) или нестандартные конструкции-обертки для кода, предоставляемые различными плагинами. То как было использовано в проекте.

__Scripted Pipeline__

В скриптовом пайплайне немного меньше формальностей и больше возможностей. Но взамен во многих случаях он требует больше "ручного управления". Например при применении скриптового пайплайна не происходит автоматическая загрузка всего необходимого кода из git-репозитория на подчиненных узлах. В коде пайплайна необходимо явно прописывать, что и откуда мы загружаем и что именно исполняем.

Пример простейшего скриптового пайплайна из документации Jenkins:

node {

    stage( ' Example ' ) {            // Здесь весь код - это скрипт

        if  (env.BRANCH_NAME == ' master ' ) {

            echo ' I only execute on the master branch '

        } else  {

            echo ' I execute elsewhere '

        }

    }

}